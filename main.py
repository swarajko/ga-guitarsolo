# -*- coding: utf-8 -*-
"""Guitaropt_proj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_qgaRXFFsNvLK1K8Ju0wr81Cqe4RkQq5
"""

import random
import matplotlib.pyplot as plt
import numpy as np
from midiutil import MIDIFile
import matplotlib.ticker as ticker

# Define the guitar's six strings (EADGBE) and their MIDI note equivalents
string_notes = {
    6: 40,  # Low E
    5: 45,  # A
    4: 50,  # D
    3: 55,  # G
    2: 59,  # B
    1: 64   # High E
}

# Define scale notes (major pentatonic + blues)
scale_notes = set([40, 42, 44, 45, 47, 49, 50, 52, 54, 55, 57, 59, 61, 62, 64, 66])
blue_notes = set([43, 48, 53, 58, 63])  # Blue notes for added bluesy feel

# Generate a random playable note
def generate_random_note():
    string = random.choice(list(string_notes.keys()))
    fret = random.randint(0, 12)
    return (string, fret)

# Generate initial population
def generate_initial_population(pop_size, solo_length):
    return [[generate_random_note() for _ in range(solo_length)] for _ in range(pop_size)]

# Improved fitness function with diversity and convergence control
def fitness_score(solo):
    playability_score = sum(abs(solo[i][1] - solo[i-1][1]) for i in range(1, len(solo)))
    musicality_score = sum(1 for note in solo if string_notes[note[0]] + note[1] in scale_notes)
    blues_expression = sum(1 for note in solo if string_notes[note[0]] + note[1] in blue_notes)
    interval_score = sum(1 for i in range(1, len(solo)) if abs(solo[i][1] - solo[i-1][1]) in [0, 2, 4, 5, 7])
    note_variance = len(set(note[1] for note in solo)) / len(solo)
    rhythmic_coherence = sum(1 for i in range(1, len(solo)) if solo[i][1] != solo[i-1][1]) / len(solo)
    string_economy = sum(1 for i in range(1, len(solo)) if abs(solo[i][0] - solo[i-1][0]) <= 1) / len(solo)
    hand_stretch = sum(1 for i in range(1, len(solo)) if abs(solo[i][1] - solo[i-1][1]) <= 4) / len(solo)

    normalized_playability = 1 / (1 + playability_score)
    normalized_musicality = musicality_score / len(solo)
    normalized_blues = blues_expression / len(solo)
    normalized_interval = interval_score / len(solo)
    normalized_variance = note_variance
    normalized_rhythm = rhythmic_coherence
    normalized_string_economy = string_economy
    normalized_hand_stretch = hand_stretch

    return (normalized_playability * 0.15 + normalized_musicality * 0.2 +
            normalized_blues * 0.1 + normalized_interval * 0.15 +
            normalized_variance * 0.1 + normalized_rhythm * 0.1 +
            normalized_string_economy * 0.1 + normalized_hand_stretch * 0.1)

# Genetic Algorithm Execution with elitism and improved visualization
def genetic_algorithm(generations=100, pop_size=20, solo_length=12):
    population = generate_initial_population(pop_size, solo_length)
    best_fitness_values = []
    avg_fitness_values = []
    mutation_rate = 0.3

    for generation in range(generations):
        fitness_scores = [fitness_score(solo) for solo in population]
        best_individual = max(zip(population, fitness_scores), key=lambda x: x[1])
        best_fitness_values.append(best_individual[1])
        avg_fitness_values.append(sum(fitness_scores) / len(fitness_scores))

        print(f"Generation {generation + 1}: Best Fitness = {best_individual[1]:.4f}, Avg Fitness = {avg_fitness_values[-1]:.4f}")

        new_population = sorted(population, key=lambda x: fitness_score(x), reverse=True)[:pop_size // 2]
        while len(new_population) < pop_size:
            child = random.choice(new_population)[:]
            if random.random() < mutation_rate:
                idx = random.randint(0, len(child) - 1)
                child[idx] = generate_random_note()
            new_population.append(child)

        population = new_population



# Minimalist color palette and dark background
    plt.style.use('dark_background')

# Create the figure and axis with a sleek look
    fig, ax = plt.subplots(figsize=(10, 6))

# Plot with smooth, anti-aliased lines in green and orange (no markers)
    ax.plot(best_fitness_values, label='Best Fitness', color='#32CD32', linewidth=3, alpha=0.9, linestyle='-', antialiased=True)  # Green
    ax.plot(avg_fitness_values, label='Average Fitness', color='#8A2BE2', linewidth=3, linestyle='-', alpha=0.9, antialiased=True)  # Orange

# Set axis labels with subtle, modern fonts
    ax.set_xlabel("Generation", fontsize=14, fontweight='normal', color='white', labelpad=15)
    ax.set_ylabel("Fitness Score", fontsize=14, fontweight='normal', color='white', labelpad=15)

# Set title with minimal styling
    ax.set_title("Evolution of Guitar Solo Fitness", fontsize=16, fontweight='bold', color='white', pad=20)

# Adjust tick parameters for a sleek, minimal look
    ax.tick_params(axis='both', which='major', labelsize=12, direction='in', length=6, width=1.5, colors='white')

# Subtle gridlines for a clean look
    ax.grid(True, linestyle='--', color='white', alpha=0.15)

# Adjust legend style to be clean and minimal
    ax.legend(loc='upper left', fontsize=12, frameon=False, labelspacing=1.2, handlelength=2.5, handleheight=1.5)

# Show the plot
    plt.show()


    print("Best Guitar Solo:")
    print(format_as_tablature(best_individual[0]))
    print(f"Final Best Fitness Score: {best_fitness_values[-1]:.4f}")
    print(f"Average Fitness of Best Generation: {avg_fitness_values[-1]:.4f}")
    return best_individual[0]

# Run Algorithm
best_solo = genetic_algorithm()